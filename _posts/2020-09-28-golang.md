---
title: golang
author: 우종선
date: 2020-09-28 09:00:00 +0800
categories: [golang]
tags: [golang]

---

## golang 

---

- golang은 stack 자료형이 없다.
- arraylist가 제공되지 않는다. 배열로 append 한다.
- append는 있지만 delete는 제공되지 않는다.
- rune 타입이라는게 있다. int 와 같은 형태지만 int와는 다르다.
- map 이 서로 같은지 비교하려면 reflect.DeepEqual(a,b)를 해야한다.
- golang은 관례상 error 값이 함수 리턴의 마지막 값이다.

```
func main() (data, error) {


}
```

- golang은 가변길이 파라미터를 지원한다.

```
package main
import "fmt"
func varchar(txt... string) {
  fmt.Println(txt)
}
func main() {
  varchar("123", "234", "234")
}
```
- golang의 메소드를 대문자로 선언하는 이유
  - golang은 따로 private, public이 없다. 
  - 메소드 이름을 대문자로 선언하면 다른 모듈에서 보인다.
  - 메소드 이름을 소문자로 선언하면 다른 모듈에서 안 보인다.

- golang에서 비동기 setTimeout을 사용하는 방법

```
time.AfterFunc(5*time.Second, func(){ 
  // 콜백으로 실행될 내용
})
fmt.Println("먼저 실행")
// 5초후 실행된다.

```

- golang에서는 enum이 따로 없다. 상수를 정의해서 사용한다.

```
type status int
const (
  UNKNOWN status = iota
  TODO
  DONE
)
func main() {
  fmt.Println(UNKNOWN) // 0 출력
  fmt.Println(TODO) // 1 출력
  fmt.Println(DONE) // 2 출력
}
```

- golang은 테스트에서 assertEqual이 없다. 직접 만들어서 써야한다.

- golang은 값에 의한 호출만 지원한다.
  - call by value
  
```
package main

import "fmt"

type Str struct {
	Name string
	Age  int
}

func funcA(str *Str) {
	str.Name = "ChangeName"
	fmt.Println(*str)
}

func main() {
	str := Str{ // 구조체를 만들고
		Name: "hello",
		Age:  10,
	}
	fmt.Println(str)
	funcA(&str) // 주소를 함수에 전달하는 방식
	fmt.Println(str)
}

```

- golang의 에러 핸들링
  - if 문에서 err := 로 대입한다. 그리고 err가 nil이 아니면 처리한다.

```
package main

import (
	"errors"
	"fmt"
)

func funcA() error {
	return errors.New("hello error")
}

func main() {
	if err := funcA(); err != nil {
		fmt.Println("error")
		fmt.Println(err)
	}
}

```

- json data의 처리

```
보통의 json 문자열의 경우에는 json.Unmarshal해서 처리한다.
func main() {
	dd := `{
		"name": "daf",
		"age": 3
	}`

	fmt.Println(reflect.TypeOf(dd))

	var obj interface{}
	err := json.Unmarshal([]byte(dd), &obj)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("--------\n", reflect.TypeOf(obj))
	}
}

Unmarshal 하면 map[string] interface{} 형태의 값을 얻을 수 있다.
```

- 그럼 이번엔 코드 데이터를 json 문자열로 변환한다.

```
type Serial struct {
	Name string
	Age  int
}

func main() {
	serial := Serial{
		Name: "hello",
		Age:  10,
	}
	byteArr, err := json.Marshal(serial)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(byteArr))
}
```

Serial이라는 구조체를 선언했다.
json.Marshal()을 하면 byte 배열이 나온다.
바이트 배열을 string() 해주면 json 문자열로 변경된다.

- map[string]string도 Json 형태로 바꿀 수 있다.

```
package main

import (
	"encoding/json"
	"fmt"
)

func main() {
	var mapTest map[string]string
	mapTest = make(map[string]string)
	mapTest["hello"] = "hihi"
	jsonMap, err := json.Marshal(mapTest)
	if err != nil {
		fmt.Println(err)
	}

	fmt.Println(string(jsonMap))
}

```

map은 make(map[string]string)처럼 make를 해서 인스턴스를 생성해야한다.

- golang에서 구조체는 필드들의 집합이다.
- golang에서 인터페이스는 함수들의 집합체이다.

```
type Person struct {
	Name string
	Age  int
}
type PersonActivity interface {
	Call()
	Work(cnt int)
}

func main() {

}
```

- golang에서 구조체와 인터페이스를 같이 쓰는 방법

```
package main

import "fmt"

type Person struct { // Person 구조체를 정의한다.
// 구조체는 클래스인데 메소드가 없다고 생각하면 된다.
	Age  int
	Name string
}

type IPerson interface { // 인터페이스를 정의한다.
// 인터페이스는 필드 없이 메소드만 있는 클래스라고 생각할 수 있다.
	IsWork() bool
	GetAge() int
	GetName() string
}

func (p Person) IsWork() bool { 
	//함수 앞쪽에 구조체를 정의한다. IsWork를 구현했으므로 IPerson 인터페이스도 구현했다.
	// 이런식으로 해당 구조체의 함수를 정의하고 쓸 수 있다.
	fmt.Println(p)
	return false
}

func main() {
	person := Person{ // 클래스처럼 객체를 만든다.
		Name: "hello",
		Age:  10,
	}
	person.IsWork() //이렇게 전달하면 IsWork에서는 p가 생성한 객체로 전달된다.
}


```

- golang defer 함수
	- golang의 defer 함수는 finally 같은 역할을 한다.
	- socket, file close에서 사용할 수 있다.

```
package main

import (
	"fmt"
	"os"
)

func main() {
	f, err := os.Open("1.txt")
	defer f.Close()

	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(f)
	// defer를 위에 썼지만 실제로 파일읽기가 close 되는 것은 main 함수가 종료되기 직전이다.
}

```

- golang panic
	- panic은 현재 함수를 멈춘다.
	- 현재 함수를 멈추고 defer를 모두 실행하고 리턴한다.
	- recover 함수를 사용하면 panic 상태를 다시 정상으로 만들 수 있다.

```
package main

import (
	"fmt"
	"os"
)

func main() {
	// 잘못된 파일명을 넣음
	openFile("Invalid.txt") // 1

	// recover에 의해
	// 이 문장 실행됨
	println("Done") // 7
}

func openFile(fn string) {
	// defer 함수. panic 호출시 실행됨
	defer func() { // 4 defer 호출
		if r := recover(); r != nil { // recover가 실행된다.
			fmt.Println("OPEN ERROR", r) // 5 
		}
	}()

	f, err := os.Open(fn) // 2
	if err != nil {
		panic(err) // 3 패닉 발생. 여기서 멈추고 defer 를 호출한다.
	}

	defer f.Close() // 6
}

```

- 고루틴, 채널

- 고루틴의 목적
	- OS 스레드보다 가볍게 비동기 처리를 하기 위해서 만들었다.
	- OS 스레드와 1:1 대응되지 않는다.
	- OS 스레드가 1MB의 스택을 갖는다. 고루틴은 몇 KB의 스택을 갖는다.(필요시 동적으로 증가한다.)

```
package main

import (
	"fmt"
	"time"
)

func say(s string) {
	for i := 0; i < 10; i++ {
		fmt.Println(s, "***", i)
	}
}

func main() {
	// 함수를 동기적으로 실행
	say("Sync") // 함수가 10번 실행된다.

	// 함수를 비동기적으로 실행
	go say("Async1") // 자바의 스레드처럼 순서를 보장하지 않는다.
	go say("Async2") // 1,2,3 이 무작위로 번갈아가면서 나온다.
	go say("Async3")

	// 3초 대기
	time.Sleep(time.Second * 3)
}

```