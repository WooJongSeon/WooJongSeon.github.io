---
title: dg-faq
author: 우종선
date: 2020-06-12 11:33:00 +0800
categories: [백엔드, node]
tags: [node]

---

## RDMS 와 Document DB의 차이점
document db 는 읽기 쓰기 성능이 뛰어나다.
document db는 스키마가 없어서 아무거나 다 저장할 수 있다.

document db에는 join 이 없다.
cascade delete 도 없다.

RDB처럼 종속삭제가 지원되지 않기 때문에 데이터를 일관되게 유지하려면 코드로 처리해야 한다.
document db 는 b트리 인덱스를 사용한다.

크기가 커질수록 새로운 데이터를 입력하거나 삭제할때 성능이 저하된다.

mongo db 는 성능이 메모리 크기에 영향을 많이 받는다.


## 몽구스 orm에 트랜잭션이 있는데 Mongo DB는 트랜잭션이 있는 것인가
mongo db도 트랜잭션이 있다.
코드상으로는 session 이라는 개념을 쓴다.
[https://docs.mongodb.com/manual/core/transactions/index.html](https://docs.mongodb.com/manual/core/transactions/index.html)

3.xx 에서는 수정 삭제시 트랜잭션을 보장하지 못하는 경우가 있다.
삭제 중인데 조회가 된다던가. 여러개의 수정행위를 보장하지 못한다던가 한다.

4.xx부터는 트랜잭션을 원활하게 지원한다.



## db 인덱스 고르는 기준
카디널리티가 높은 순서로 고른다.
인덱스를 1개의 컬럼에만 걸어야 한다면 카디널리티가 가장 높은 것을 잡아야 한다.
카디널리티란 해당 컬럼의 중복된 수치를 나타낸다.
예를 들어서 성별, 학년은 카디널리티가 낮다. 
주민등록번호, 계좌번호 이런것 들은 카디널리티가 높다.

카디널리티란 컬럼의 중복도에 관한 내용이다.
중복도가 낮으면 카디널리티가 높다.
중복도가 높으면 카디널리티가 낮다.

되도록 업데이트가 빈번하지 않은 컬럼으로 인덱스를 구성한다.
where 절에서 자주 사용하는 컬럼에는 인덱스 추가를 고려한다.
join시 자주 사용하는 컬럼은 인덱스로 등록한다.

단일 인덱스 여러개보다 다중컬럼 인덱스의 생성을 고려한다.

## mysql 적정 인덱스 개수 선택을 어떻게 할지
몇개가 적당하다기 보다는 카디널리티가 높은 컬럼을 인덱스로 지정하는 것이 좋다.
카디널리티가 높은 컬럼의 예시 - 주민등록번호, 계좌번호


## mysql 쿼리 성능 어떻게 감지하는지
explain 쿼리를 사용하면 해당 쿼리에 대한 정보가 나타난다.

|id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |

| 1 |    SIMPLE   | links |   null     | ALL  |       null    | null|   null  |null | 61   |  11.11   |Using where|

type ALL의 경우에는 풀스캔을 한다는 말이다.

## DB 에서 데드락이 발생하는것
교착상태는 여러 개의 트랜잭션이 실행을 하지 못하고 서로 무한정 기다리는 상태를 말한다.

막을 수 있는 방법
 - 예방 기법
    - 트랜잭션 실행 전에 데이터를 모두 로킹한다.
    - 모두 로킹해야 하므로 실질적으로 트랜잭션의 병행성을 보장하지 못한다.
    - 몇몇 트랜잭션은 계속해서 처리를 못할 수도 있다.

 - 회피 기법
    - 자원을 할당할때 타임스탬프를 써서 교착상태가 일어나지 않도록 회피한다.
    - wait die 방식과 wound wait방식이 있다.
    - wait die 방식은
      - 타임스탬프 값이 작은데 먼저 실행되었다면 대기한다.
      - 타임스탬프 값이 작은데 나중에 시작되었다면 취소하고 다음에 같은 타임스탬프로 다시 실행한다. <- 아래 방식과의 차이

    - wound wait 방식은
      - 타임스탬프 값이 작은데 먼저 실행되었다면 나중에 실행된 더 큰 타임스탬프를 가진 트랜잭션을 취소하고 나중에 다시한다.
      - 타임스탬프 값이 작은데 나중에 실행되었다면 대기한다.


 - 타임스탬프를 필요로 하지 않는 예방 기법
    - 비대기 알고리즘 
      - 트랜잭션이 로크를 획득 할 수 없을때 즉시 철회하고 일정 시간이 경과하면 재시작한다.

    - 신중 대기 알고리즘
      - 트랜잭션이 로크를 획득하려고 할때 다른 트랜잭션 Tj가 이미 로크를 보유하고 있다면
      - 다른 트랜잭션Tj가 블록된 상태가 아니면 Ti는 블록되고 대기한다.
      - Tj가 블록된 상태라면 Ti를 철회한다.


## DB 확장을 어떻게 할지

데이터베이스 확장에는 두 종류가 있다.
- 수평 확장
  - 수평 확장은 분산시스템 내의 노드의 개수를 늘리는 것을 말한다.

- 수직 확장
  - 수직 확장은 시스템 내의 개별적인 노드의 능력을 확장하는 것을 말한다.
  - 해당 서버가 다운되면 시스템이 다운된다.

확장 방법
 샤딩을 활용해서 DB 트래픽을 분산하게 된다.
 
모듈러 샤딩도 있고 레인지 샤딩도 있다.

모듈러 샤딩은 PK를 모듈러 연산한 결과로 DB를 특정하는 방식이다.
1,3,5,7 = A 데이터베이스
2,4,6,8 = B 데이터베이스
=> 장점: 데이터가 비교적 균일하게 분산된다.
=> 단점: 추가 증설과정에서 이미 적재된 데이터의 재정렬이 필요하다.


레인지 샤딩은 PK의 범위를 기준으로 DB를 나눈다.
1,2,3,4 = A 데이터베이스
5,6,7,8 = B 데이터베이스
=> 장점 = 모듈러에 비해서 증설에 재정렬이 필요 없다.
=> 단점 = 일부 DB에 데이터가 몰릴 수 있다.


## 프로토 타입 내부에서만 프라이빗하게 쓰는 방법

```
function Gadget() {
  let name = 'hello'
  this.getName = () => {
    return name;
  }
}

(() => {
  const toy = new Gadget()
  console.log(`toy name ${toy.name}`); // 접근 할 수 없어서 undefined가 출력된다.
  console.log(toy.getName()); // 함수로 접근 가능하다.
  // 클로저 개념을 활용해서 private 한 필드를 만들었다.
})();


// 응용해서 private 한 함수도 만들어보자.
function MakePrivate() {
  const privateMethod = () => {
    console.log('this is private');
  }
  this.publicMethod = () => {
    console.log('this is public');
  }
}

(() => {
  const priv = new MakePrivate();
  priv.privateMethod(); // 접근 할 수 없어서 에러가 난다.
  priv.publicMethod();
})();

```

## 프로토 타입의 장점
메모리 낭비를 줄일 수 있다.

## 혼자 개발하면 로그인을 어떻게 구현할지
jwt 토큰을 활용한 인증 방식을 쓴다.



## 유저 토큰을 탈취해서 jwt 토큰으로 서비스에 접속하면 1개 요청은 잘못된 요청인데 어떻게 식별할지
요청 헤더에 hmac 같은 메세지를 함께 보내도록 한다.
그래서 잘못된 요청을 감지한다.


## Jwt 토큰이 뭔가요
Json Web Token의 줄임말이다.
. 을 구분자로 3가지의 문자열로 구성되어 있다.
aaaa.bbbb.cccc
헤더.내용.서명

- 헤더 = 2가지의 정보를 갖고 있다.
  - type: 토큰의 타입을 지정한다. 타입은 JWT
  - alg: 해싱 알고리즘을 지정한다. 보통 HMAC, SHA256,RSA 를 쓴다.

- 정보 = payload 부분에는 토큰에 담을 정보가 들어있다.
  - 담는 정보의 한 조각을 클레임이라고 부른다. name: value 한 쌍으로 되어있다.
  - 클레임의 종류
    - 등록된 클레임: 서비스에서 필요한 정보가 아닌 토큰에 대한 정보를 담으려고 이름이 정해진 클레임
      - iss

    - 공개 클레임
    - 비공개 클레임



## 쿼리를 짤때 하면 안되는 습관
인덱스를 조회 할 때 where id in (1,2,3,4,5) 이렇게 상수 값으로 하는 것은 문제가 없다.
그러나 in 에 서브쿼리를 넣게되면 성능 이슈가 발생한다.

인덱스가 사용되지 않도록 쿼리하는 것은 안된다.
예를 들어서 group_no, from_date, is_bonus로 인덱스를 만들었다고 해보자.
이때 조회 쿼리를 where group_no=123 and is_bonus=yy and from_date > 0722 이런식으로 하면
is_bonus는 인덱스가 사용되지 않는다.

where 절에서 or를 잘못 사용하면 풀스캔이 일어날 수 있으므로 주의한다.

인덱스로 사용된 컬럼 값을 그대로 사용해야 인덱스가 사용된다.

where salary * 10 > 15000 은 인덱스를 쓰지 못한다.
where salary > 15000 / 10은 인덱스를 쓸 수 있다.


## 조인을 사용할때 유의사항

조인할때 순서에 유의해야 한다.
A 테이블, B 테이블, C 테이블이 있다고 해보자.
C테이블은 A와 B를 참조하는 관계테이블이다.

이때 A,B,C 테이블을 조인해서 모든 컬럼을 가져온다면 아래 순서로 조인해야 한다.
A,C를 조인한다면 select * from A left join C on A.id = C.Aid가 된다.
이러면 쿼리 타입이 ALL이 된다.

ALL이 되는 이유는 A테이블이 C에 없는 Aid 행을 모두 가지고 있기 때문이다.

이럴때는 인덱스를 쓰면 쿼리 타입을 ALL 에서 인덱스로 바꿀 수 있다.

- 쿼리 타입이 ALL 인 경우
explain select * from archives left join links l on archives.id = l.archiveId;

- 쿼리 타입이 index인 경우
explain select * from archives left join links l on archives.id = l.archiveId order by archives.id desc;

차이점은 인덱스가 있는 컬럼에다가 order by를 걸어줬다.

## 조인 쿼리의 성능을 올리는 방법
너무 많은 테이블을 조인하지 않는다.
조인하는 테이블이 늘어날수록 쿼리 성능이 떨어진다.


## MSA 로깅을 어떻게 처리할지
일단 디스크 IO는 비용이 큰 작업이므로 하지 않는다.
로그는 외부에 저장해야 한다.
외부화 하지 않은 로그는 파편화되고 추적하기 어려워진다.

로그를 관리해주는 플랫폼이나 서비스를 사용하는 것이 좋다.
예를 들면 datadog 같은 것을 쓴다.

중앙 집중형 방식을 쓴다.
이렇게 하면 로컬 I/O는 쓰지 않는다. 로컬 장비의 디스크 공간을 쓰지 않아도 된다.
잦은 로컬 디스크 I/O는 애플리케이션을 느려지게 할 수도 있다.

## 메트릭 수집 어떻게 할지
메트릭을 수집한다는 것은 대상의 리소스 사용률, 트래픽같은 것들에 대한 정보를 수집한다는 것이다.
프로메테우스, Telemetry 같은 툴을 사용해서 해볼 수 있다.

대부분의 메트릭 수집, 모니터링 툴은 아래와 같이 동작한다.
각 서버에 클라이언트를 설치한다.
그리고 이 클라이언트가 메트릭 데이터를 수집해서 중앙 서버로 보낸다.
그러면 이 중앙 서버가 모니터링 상태를 보여준다.

프로메테우스의 경우에는 아래와 같이 동작한다.
pull 방식으로 동작한다.
서버가 주기적으로 클라이언트에 접속해서 메트릭을 pull 요청하고 받아간다.


## msa로 나눠서 작업할때 서로 필드가 변경되거나 했을때 어떻게 알리고 처리할지
내부적으로 배포 알림 봇같은 것을 만들어서 활용하는 방법이 있다.


## msa 에서 느린응답 장애가 발생했을때 해결할 방법

## 좋아요 기능을 구현할때 어떻게 100개의 게시글의 좋아요 개수를 가져올 수 있을지
레디스의 하이퍼 로그 기능을 활용한다.
하이퍼 로그는 유일한 값을 가지는 키에 대해서 value 를 가질 수 있다.

[https://stackoverflow.com/questions/55041614/redis-getting-user-likes-for-mutiple-posts-in-a-single-call](https://stackoverflow.com/questions/55041614/redis-getting-user-likes-for-mutiple-posts-in-a-single-call)



## 캐시 무효화를 어떻게 할지
업데이트시 api 를 호출해서 캐시 정보를 업데이트 하도록 한다.
예를 들어서 고객 서비스와 주문 서비스가 있고.
주문 서비스에서 고객 정보 목록을 캐시해서 가지고 있다면.

고객 서비스에서 고객 정보가 업데이트되면 주문 서비스의 api 를 호출한다.
주문 서비스의 api가 호출되면 사이드카 패턴으로 함께 배포한 레디스 캐시의 해당 값을 업데이트한다.

## 유용한 node js 디자인 패턴
프록시 패턴


## Tsconfig에서 유용한 설정
external decorator 설정
Json ignore 라던지 실험적인 데코레이터를 활용 할 수 있다.

