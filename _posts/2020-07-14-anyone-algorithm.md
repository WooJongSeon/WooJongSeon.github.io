---
title: 누구나 자료구조와 알고리즘
author: 우종선
date: 2020-07-14 11:33:00 +0800
categories: [Algorithm, node]
tags: [알고리즘, node]

---


## 누구나 자료구조와 알고리즘

## 1장 - 자료구조

- 읽기 = 배열 읽기
 - 컴퓨터는 배열을 앞에서부터 하나씩 읽는다.
 - 배열의 특정 인덱스에 접근하는 것은 O(1)이 걸린다.

- 검색 = 배열을 앞에서부터 하나씩 읽는다.

- 삽입 = 배열에 원소를 삽입한다.
 - 맨 뒤에 삽입하는 것은 간단하다.
 - 맨 앞이나 중간은 배열의 기존 원소들을 옮겨야 한다.

- 삭제 = 맨 뒤의 원소를 삭제하는 것은 간단하다.
 - 맨 앞, 중간 원소를 삭제하는 것은 기존 원소를 옮겨야 한다.

## 2장 - 알고리즘

- 정렬된 배열
 - 정렬된 배열은 검색이 간단하다.
 - 정렬된 배열은 삽입에 불리하다.
 - 정렬되지 않은 배열은 아무데나 원소를 넣으면 된다.
 - 정렬된 배열은 정해진 순서에 넣어야 한다.

- 정렬된 배열의 장점
 - 이진 탐색이 가능하다.

- 이진 탐색
 - logN의 시간이 걸린다.
 - 정렬된 배열의 가운데부터 탐색해서 절반씩 소거한다.
 - O(N)의 선형 탐색보다 빠르다.

## 3장 빅 오 표기법
- 로가리즘
 - 로그는 해당 숫자를 몇번 곱해야 N을 얻을 수 있는지를 말한다.

![log](https://slideplayer.com/slide/2562897/9/images/5/Logarithmic+Functions+%28continued%29.jpg)

log2의 8은 8을 만들려면 2를 몇번 곱해야 하는지를 말한다.

계산복잡도를 말할때 보통 아래 2는 생략하고 logN 이런식으로 말한다.

O(log8) 은 계산까지 3단계가 걸린다.
O(logN) 은 O(N)보다 훨씬 빠르다.

O(1024)일 경우 1024 step이 걸린다.
O(log1024) => 10 step이 걸린다.

O(logN)은 N이 2배 증가할때 1단계 연산이 증가한다.

```
해당 숫자가 소수인지 판별하는 알고리즘
def is_prime(number):
  for i in range(2,number):
    if number % i == 0:
      return false
  return true
```
2부터 number까지의 모든 수로 number를 나눠서 나머지가 있는지 확인한다.
나머지가 없으면 소수가 아니니까 false를 반환한다.

number까지 모두 나눴는데 나머지가 있으면 이 수는 소수이다.
알고리즘의 효율성은 O(N)이다.

## 4장 빅 오로 코드 속도 올리기

버블정렬
- 버블정렬은 배열을 앞에서부터 순회하면서 2쌍씩 비교하고 교체하는 방식이다.

3 1 2 

1 3 2 - 1과 3의 위치를 바꾼다.

1 2 3  - 2와 3의 위치를 바꾼다.

이 알고리즘은 O(N제곱)의 시간이 걸린다.
원소 10개가 역순으로 된 배열에서는
9 8 7 6 5 4 3 2 1 총 45번 비교하고 45번 교환해야 한다.
90단계다.

20개는 190번 비교, 190번 교환한다.
원소가 늘어날수록 단계수가 기하급수적으로 증가한다.

| 원소 수 | 단계 |
|:--------|:--------:|
| 5 | 20 | 
| 10 | 90 | 
| 20 | 380 | 
| 40 | 1560 | 
| 80 | 6320 | 

O(n제곱)은 이차시간이라고도 부른다.

이차문제
- ex) 배열에서 중복되는 값을 찾는 방법

배열에서 중복된 값이 있는지 찾는 최악의 방법은 반복문을 중첩해서 쓰는 것이다.
O(n제곱)의 단계가 걸린다.
이를 선형 해결법으로 O(N)으로 만들 수 있다.
중간에 if 문을 써서 만든다.

```
function hasDuplicateValue(array) {
  var steps = 0;
  var existingNumbers = [];
  for(var i = 0 ; i < array.length ; i++ ) {
    steps++;
    if(existingNumbers(array[i] === undefined)) {
      existingNumbers[array[i]] = 1;
    } else {
      return true;
    }
  }
  console.log(steps);
  return false;
}
```

## 5장 빅오를 사용하거나 사용하지 않는 코드 최적화

- 선택정렬

선택 정렬은 아래와 같이 동작한다.
```
5 4 3 1 2
앞에서부터 탐색해서 1이 제일 작다는 것을 알아낸다.
맨 앞의 5와 1의 위치를 바꾼다.
1 4 3 5 2
앞에서부터 다음 작은 수인 2를 찾아낸다.
4와 2를 바꾼다.
1 2 3 5 4
그 다음 3을 찾았다. 3은 현재 남은 숫자 3 5 4 중에서 제일 작다.
1 2 3 5 4
5부터 시작해서 제일 작은 숫자 4를 찾았다.
4와 5를 바꾼다.
1 2 3 4 5 정렬이 완료되었다.
```

- 상수 무시하기

빅 오 표기법에서는 앞에 적힌 상수를 무시한다.
O(2N) 도 O(100N)도 O(N)이다.

- 빅 오의 역할
빅 오 표기법은 알고리즘의 N이 크게 증가할때 장기적인 시간 복잡도를 표시 할 수 있다.

- 빅 오 표기법에는 드러나지 않지만 차이 나는 성능

버블 정렬과 선택 정렬은 둘다 N제곱이지만 선택 정렬이 버블 정렬보다 2배 빠르다.

## 6장 긍정적인 시나리오 최적화
- 삽입 정렬
```
삽입 정렬은 중간 데이터를 temp_value 에 담았다가 위치를 바꾸는 방식이다.
42713 에서
2를 먼저 temp_value 에 담는다.

이제 4와 temp_value 를 비교한다.
4가 더 크기때문에 오른쪽으로 옮긴다.
24713이 된다.
다음은 7을 temp_value에 저장한다.

4가 더 작기 때문에 옮기지 않는다.
다음은 1을 temp_value 에 담는다.

7은 1보다 크니까 오른쪽으로 한칸 옮긴다.
4도 1보다 크니까 오른쪽으로 옮긴다.
2도 1보다 크니까 오른쪽으로 옮긴다.
오른쪽으로 한칸 씩 옮기고 1을 맨 앞으로 넣는다.
12473이 된다.

이제 3을 temp_value 에 담는다.
7부터 하나씩 비교해서 오른쪽으로 옮긴다.
4를 옮기고 3을 넣는다.
12347이 된다.
```
배열이 역순으로 되어 있는 경우
각 숫자마다 왼쪽에 있는 모든 숫자와 비교해야 한다.
그런 경우 N제곱만큼 걸린다.

선택정렬과의 비교
- 선택 정렬은 N제곱 /2 가 걸린다.

최악의 경우 선택정렬이 더 빠르고
최선의 경우 삽입정렬이 더 빠르다.

최선의 경우 위치를 바꿀 필요가 없고 1부터 n 까지 탐색만 하면 된다.

경우에 따라 맞는 방법을 선택해서 사용해야 한다.
어느정도 정렬된 경우에는 삽입정렬
최악의 경우라면 선택정렬


## 7장 해시 테이블로 매우 빠른 작업

해시 테이블은 O(1)의 시간 복잡도를 가진다.

대부분의 프로그래밍 언어에는 해시, 맵, 해시 맵, 딕셔너리 등의 자료 구조가 있다.

키를 통해서 값을 찾는다.

해시는 주어진 해싱 함수를 통해서 특정 값으로 매핑한다.

- 해시 충돌
해시테이블에 따라서 값을 매핑했는데
서로 다른 값이 같은 값으로 매핑되는 경우를 말한다.

- 해시 충돌을 해결하는 방법
  - 분리 연결법 = 배열에 충돌되는 값들을 배열로써 저장한다.
  충돌되는 값들을 다른 배열에 저장한다.
  그리고 저장한 배열의 주소를 해시로 매핑되는 곳에 넣는다.

해시를 활용하면 O(N)이 걸리는 탐색을 key value로 O(1)로 탐색할 수도 있다.

## 8장 스택과 큐로 간결한 코드 생성
괄호 오류 탐지
- 괄호가 